%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Copyright (C) 2017-2019 Tactical Computing Laboratories, LLC
% All Rights Reserved
% contact@tactcomplabs.com
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{article}

\usepackage[margin=1.0in]{geometry}
\usepackage[version=3]{mhchem} % Package for chemical equation typesetting
\usepackage{siunitx} % Provides the \SI{}{} and \si{} command for typesetting SI units
\usepackage{graphicx} % Required for the inclusion of images
%\usepackage{natbib} % Required to change bibliography style to APA
\usepackage{amsmath} % Required for some math elements 
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[parfill]{parskip}
\usepackage{array}
\usepackage{algorithm}
\usepackage{algcompatible}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{courier} % for \texttt{}
\usepackage{dirtree}
\usepackage{multirow}
\usepackage{draftwatermark} % required for watermarks
\usepackage{vhistory}
\RequirePackage{epstopdf}
\RequirePackage{tabularx}
\RequirePackage{xstring}
\RequirePackage{hyperref}
\RequirePackage{fancyhdr}

%-- setup paragraphs and margins
\setlength{\parindent}{1em}
\setlength{\parskip}{1em}

\SetWatermarkText{DRAFT}
\SetWatermarkScale{5}

%-- code listing setup
\lstdefinestyle{base}{
  language=C++,
  numbers=left,
  stepnumber=1,
  emptylines=1,
  breaklines=true,
  basicstyle=\ttfamily\color{black},
  moredelim=**[is][\color{red}]{@}{@},
}

%-- setup hyperlinks
\hypersetup{
  colorlinks=true,
  linktoc=all,
  linkcolor=black,
  citecolor=black,
  urlcolor=black
}
%--

\setlength\parindent{0pt} % Removes all indentation from paragraphs

\renewcommand{\labelenumi}{\alph{enumi}.} % Make numbering in the enumerate environment by letter rather than number (e.g. section 6)

%\usepackage{times} % Uncomment to use the Times New Roman font
%----------------------------------------------------------------------------------------
%	DOCUMENT LAYOUT INFORMATION
%----------------------------------------------------------------------------------------
\pagestyle{fancy}
\lhead{}
\chead{\textbf{StoneCutter Language Spec v.0.1}}  % -- classification
\rhead{}
\lfoot{} %-- format: TR YYYY-RRR-V.V; y = year; r = report; v = version
\cfoot{\textbf{StoneCutter Language Spec v.0.1}}  % -- classification
\rfoot{\thepage}      % -- page number

%----------------------------------------------------------------------------------------
%	DOCUMENT INFORMATION
%----------------------------------------------------------------------------------------

\title{StoneCutter Language\\Specification} % Title

\author{Tactical Computing Laboratories, LLC} % Author name

\date{} % Date for the report

\begin{document}

%-- begin TCL logo
\begin{figure}
\begin{center}
\includegraphics[width=5in]{figures/stonecutter.png} % Include the logo
\end{center}
\end{figure}
%-- end TCL logo

\maketitle % Insert the title, author and date
\thispagestyle{fancy} %-- force the fancyhdr

\begin{center}
\begin{tabular}{l r}
Date: & February 15, 2019 \\ % Date the experiment was performed
Revision: & 0.1 \\         % revision number
Authors: & Tactical Computing Labs\\ % Author names
& contact@tactcomplabs.com\\
\end{tabular}
\end{center}

% If you wish to include an abstract, uncomment the lines below
% \begin{abstract}
% Abstract text
% \end{abstract}

%----------------------------------------------------------------------------------------
%       TOC
%----------------------------------------------------------------------------------------

\clearpage
\tableofcontents
\clearpage

%----------------------------------------------------------------------------------------
%       List of Document Elements
%----------------------------------------------------------------------------------------

\clearpage
\listoffigures
\lstlistoflistings
\listoftables
%\listofalgorithms
\clearpage

%----------------------------------------------------------------------------------------
%       Changelog
%----------------------------------------------------------------------------------------

\clearpage
\begin{versionhistory}
  \vhEntry{0.1}{02.15.2018}{JLeidel}{Initial public release}
\end{versionhistory}
\clearpage

%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------
\clearpage
\section{Overview}

The StoneCutter language is utilized to develop the implementation of a 
single instruction within the System Architect design workflow.  The StoneCutter 
language abstracts a large portion of traditional high level design languages such 
that the user may focus on the implementation details of a single instruction rather 
than the connectivity to the remainder of the infrastructure.  The core features of 
the StoneCutter language infrastructure are noted as follows: 

\begin{itemize}
\item \textbf{Compiled Language}: Unlike other HDL approaches, the StoneCutter language 
is, in fact, compiled.  The core StoneCutter compiler infrastructure makes use of the LLVM 
compiler infrastructure for lexing, parsing, optimization and code generation.  As a result, we have 
the ability to initiate traditional optimizing compiler passes, syntax tests and lexical analysis as 
other compiled languages.  Further, we have the ability to craft tooling that integrates with the StoneCutter 
language in the same manner as traditional compiled languages.  

\item \textbf{Integration with CoreGen IR}: The StoneCutter language and associated tooling is architected 
in a manner that permits integration with the CoreGen intermediate representation (IR)~\cite{IRSpec}.  This 
is done in two ways.  First, users have the ability to write StoneCutter instruction definitions inline within the 
CoreGen IR.  These \texttt{Impl} definitions are directly embedded within the overarching design.  Second, 
the CoreGen IR can be utilized to verify the I/O architecture and instruction format for each StoneCutter 
instruction definition.  This ensures that the prescribed instruction format in the CoreGen design is \textit{verified} 
to be functionally correct prior to utilizing downstream synthesis tools.      

\item \textbf{C-Like Syntax}: Unlike other HDL approaches, the StoneCutter language utilizes a familiar 
syntactical structure that is designed to mimic traditional C procedural methods.  Each instruction definition 
is contained within an effective function body with incoming arguments (registers).  Arithmetic, boolean operations, 
conditional operations and loop structures all mimic traditional procedural C syntax.  In this manner, the learning 
curve required to be productive with StoneCutter is minimized.  

\item \textbf{Support for Intrinsics}: Much in the same manner as traditional procedural languages such as C, 
StoneCutter has support for inline intrinsic operations.  Intrinsic operations are designed to support optimized 
circuits for pathological operations such as sign/zero extension, multi-input operations (majority vote, etc) and 
special arithmetic operations.  As the StoneCutter language continues to develop, we plan to augment the list 
of supported intrinsics.  

\end{itemize}


The remainder of this language specification is organized as follows.  Section~\ref{sec:StoneCutterLanguage} 
introduces the StoneCutter language and the associated syntax.  Section~\ref{sec:IntrinsicFunctions} provides 
details associated with each of the currently supported intrinsics.  Section~\ref{sec:AppendixA} provides 
a sample set of StoneCutter instruction definitions.  Section~\ref{sec:AppendixB} provides a consolidated list of StoneCutter 
intrinsics.  

 
%----------------------------------------------------------------------------------------
%	SECTION 2
%----------------------------------------------------------------------------------------
\clearpage
\section{StoneCutter Language}
\label{sec:StoneCutterLanguage}

\subsection{Overview}
\label{sec:LangOverview}

As mentioned above, the StoneCutter language is designed to take instruction definitions in a procedural syntax, 
optimize the instruction body and output each instruction in Chisel HDL.  As shown in Figure~\ref{fig:SCArch}, input 
files or buffers are parsed into an appropriate AST.  Instruction intrinsics are recognized and annotated in the AST.  Further, 
register classes and registers are identified and marked as special globals.  The AST is then translated to standard 
LLVM intermediate representation (IR).  The tools utilize standard LLVM optimization passes to optimize the instruction IR.  
The tools then execute a series of StoneCutter-specific IR passes against the optimized LLVM IR in order to ensure that the 
instruction design is correct per the prescribed instruction format(s).  Once verified as correct, the instruction intrinsics are expanded inline and the 
tools generate Chisel HDL.

\begin{figure}[h]
\begin{center}
\includegraphics[width=\textwidth]{figures/scarch.pdf}
\vspace*{8pt}
\caption{StoneCutter Architecture}
\label{fig:SCArch}
\end{center}
\end{figure}

Each StoneCutter input file is constructed is a specific, prescribed manner.  The organization of the data members and 
the instruction definitions is done so specifically to elicit global and local hardware state within and across individual instructions.  
We find a sample of the StoneCutter file layout in Listing~\ref{lis:scoverview}.  
StoneCutter input files begin with an optional comment block describing the contents of the file.  Next, the individual register 
classes are defining for use by the instructions.  These register classes should match the register class definitions in name and 
layout found in the respective CoreGen design input.  Further information regarding the definition of register classes can 
be found in Section~\ref{sec:RegClassDef}.  The next portion of the file includes the actual instruction definitions.  Each 
instruction definition is comprised of a \textit{function}-like structure denoted with a \texttt{def} keyword.  Each instruction 
takes some number of instruction arguments (I/O's) and contains private variables and arithmetic logic.  Notice how 
the variable definitions are made near the top of the instruction definition.  Much like the C language, this is required 
in StoneCutter in order to preemptively understand the scope of the temporary variables defined in the instruction.  
Sections~\ref{sec:InstructionPrototypes}-\ref{sec:LoopOperations} 
describe the rudimentary operations and the associated syntax that can be included in the instruction 
definition body.  

\clearpage
\vspace{0.125in}
\begin{lstlisting}[frame=single,style=base,caption={StoneCutter File Structure},captionpos=b,label={lis:scoverview}]
#
# Sample StoneCutter File Layout
#

# Instruction Formats
instformat FORMAT1( FIELDTYPE FIELD1, FIELDTYPE FIELD2, ... )

# Register Class Definitions
regclass CLASS1( DATATYPE REG1, DATATYPE REG2, ... )
regclass CLASS2( DATATYPE REG3( DATATYPE SUBREG1, DATATYPE SUBREG2 ) )

# Instruction Definitions
def INST1( INPUT1 INPUT2 INPUT3 ) {
	# Variable Definitions
	DATATYPE VAR1, VAR2, VAR3
	DATATYPE VAR4
	
	# Instruction Body
	VAR4 = INPUT2 + INPUT1
	VAR1 = INPUT1 << 1
	VAR2 = INPUT3 << 2
	VAR3 = INPUT1 + INPUT2
	INPUT1 = VAR3
}

def INST2( REG1 REG3 SUBREG1 ) {
	# Instruction Body
	REG1 = REG3 * SUBREG1
}
\end{lstlisting}

\subsection{Syntactical Notes}
\label{sec:SyntacticalNotes}

Prior to reading the remaining sections, we highly suggest users and readers 
understand the following syntactical notes.  Understanding these notes will significantly 
reduce the time required to become productive in StoneCutter.  

\begin{itemize}
\item \textbf{Semicolons}: Unlike the C language, StoneCutter does not require utilizing semicolons (\texttt{;}) 
to terminate an expression.  All raw expressions are in static single assignment (SSA) form.  This implies 
that each expression will be in the form of \texttt{TARGET = INPUT <OP> OUTPUT}.  The only exception 
to this rule is when intrinsics are utilized.  A call to an intrinsic function may be

\item \textbf{Complement Operations}: The StoneCutter language contains all the standard arithmetic, boolean 
and logical operations except complements.  The bitwise complement operator from C (\texttt{\~}) is not supported 
and the boolean complement operator from C (\texttt{!}) is not supported.  Complementing the result of a boolean 
operation and/or performing the bitwise complement of a variable or register must be performed using the \texttt{NOT} 
intrinsic.  See Section~\ref{sec:NOT} for more details.   
\end{itemize}

\clearpage
\subsection{Comments}
\label{sec:Comments}

Inline comments and comment text in StoneCutter must begin with the pound (\texttt{\#}) sign.  Comments 
may begin on new lines on inline with other code.  Examples of using comments are shown in Listing~\ref{lis:comments}.  

\vspace{0.125in}
\begin{lstlisting}[frame=single,style=base,caption={StoneCutter Comments},captionpos=b,label={lis:comments}]
# This is a stand alone comment
def inst0(RA RB RT) {   # this is an inline comment
	RT = RA + RB
}
\end{lstlisting}

\clearpage
\subsection{Datatypes}
\label{sec:Datatypes}

Much in the same manner as traditional programming models such as C and C++, StoneCutter 
supports a common set of datatypes for intermediate variables and registers.  However, unlike 
traditional programming models, hardware design languages are required to support datatypes 
in non-byte aligned types.  In order to provide more hardware-centric support, StoneCutter supports 
traditional data types as well as arbitrary width signed and unsigned integer types.  These types are 
documented in Table~\ref{tab:datatypes}. 

\begin{table}[h]
\begin{center}
\caption{StoneCutter Datatypes}
\vspace{0.125in}
\label{tab:datatypes}
\begin{tabular}{|c|c|l|}
\hline
\textbf{Type} & \textbf{Width (in bits)} & \textbf{Description}\\
\hline
\texttt{bool} & 1 & Boolean.  Analogous to unsigned 1 bit integer (\texttt{u1})\\
\hline
\texttt{u8} & 8 & Unsigned 8 bit integer. Analogous to \texttt{uint8\_t}\\
\hline
\texttt{u16} & 16 & Unsigned 16 bit integer. Analogous to \texttt{uint16\_t}\\
\hline
\texttt{u32} & 32 & Unsigned 32 bit integer. Analogous to \texttt{uint32\_t}\\
\hline
\texttt{u64} & 64 & Unsigned 64 bit integer. Analogous to \texttt{uint64\_t}\\
\hline
\texttt{s8} & 8 & Signed 8 bit integer. Analogous to \texttt{int8\_t}\\
\hline
\texttt{s16} & 16 & Signed 16 bit integer. Analogous to \texttt{int16\_t}\\
\hline
\texttt{s32} & 32 & Signed 32 bit integer. Analogous to \texttt{int32\_t}\\
\hline
\texttt{s64} & 64 & Signed 64 bit integer. Analogous to \texttt{int64\_t}\\
\hline
\texttt{float} & 32 & Single precision floating point\\
\hline
\texttt{double} & 64 & Double precision floating point\\
\hline
\texttt{uN} & N bits & Arbitrary unsigned integer of N bits\\
\hline
\texttt{sN} & N bits & Arbitrary signed integer of N bits\\
\hline
\end{tabular}
\end{center}
\end{table}

An example of defining arbitrary width integers is shown in Listing~\ref{lis:arbwidth}.  

\vspace{0.125in}
\begin{lstlisting}[frame=single,style=base,caption={Arbitrary Width Datatypes},captionpos=b,label={lis:arbwidth}]
#-- unsigned 7 bit integer "foo"
u7 foo

#-- unsigned 1024 integer "bar"
u1024 bar

#-- signed 37 integer "foobar"
s37 foobar
\end{lstlisting}

\clearpage
\subsection{Instruction Format Definitions}
\label{sec:InstFormatDef}

Instruction formats and their associated fields are special variables in the StoneCutter language.  Each defined 
instruction field must reside within a respective instruction format.  Instruction fields are marked in the IR with 
attributes in order to ensure that they are correctly associated with the correct instruction format.  Further, for each 
field that is denoted as a register field, the associated register class must also be specified in order to correctly 
link the register read datapath to the correct register file.  Each of the associated fields is annotated as a global 
variable such that is can be explicitly utilized in any instruction prototype or instruction body.  

\begin{table}[h]
\begin{center}
\caption{StoneCutter Instruction Format Field Types}
\vspace{0.125in}
\label{tab:instformatfields}
\begin{tabular}{|c|c|c|l|}
\hline
\textbf{Field} & \textbf{Mnemonic} & \textbf{Read/Write Access} & \textbf{Description}\\
\hline
\multirow{2}{*}{Instruction Encodings} & \texttt{enc} & Read-Only & Instruction encodings such as\\
												  & & & opcodes and function codes\\
\hline
\multirow{2}{*}{Immediate Values} & \texttt{imm} & Read-Only & Immediate values encoded in the\\
											      & & & instruction payload\\
\hline
\multirow{3}{*}{Register Indices} & \texttt{reg[REGCLASS]} & Read-Write & Register index encodings.\\
														& & & Must include the respective\\
														& & & REGCLASS\\
\hline
\end{tabular}
\end{center}
\end{table}

For each field in the instruction format, the respective field is designated with a field type and a field name.  There are 
three types of instruction field types.  First, instruction fields denoted as encoding fields are utilized to designate 
individual instruction encodings such as opcodes and function codes in RISC architectures.  When utilizing these fields 
in the implementation of an instruction, the value contained within the field is utilized.  For example, if an instruction 
defines a field \texttt{opc} that contains the values 0x0A hex, reading from this field will provide the exact value 0x0A hex.  
Second, immediate fields are immediate values encoded directly within the instruction payload.  Reading from immediate 
fields from within the instruction payload will read the literal immediate from the instruction payload.  Finally, register fields 
denote register indices that access a single register file.  Reading from this field directly will not deliver the index.  Rather, accessing 
a register field will read or write the value at the designated index of the target register file.    
For fields that are denoted as register class fields (\texttt{reg}), the associated register class (register file) must also be specified.  
We summarize the permissible instruction field types in Table~\ref{tab:instformatfields}.  Further, the syntax for the an entire instruction 
format block is shown in Listing~\ref{lis:instformat}.  Encoding and immediate fields are always marked as read-only.  Only 
register fields may be written to.  

\vspace{0.125in}
\begin{lstlisting}[frame=single,style=base,caption={Instruction Format Definition Syntax},captionpos=b,label={lis:instformat}]
instformat FName1( FIELDTYPE FIELD1, FIELDTYPE FIELD2, ... )
instformat FName2( reg[REGCLASS] FIELD1, ... )
\end{lstlisting}

We find an example instruction format definition for a simple RISC ISA with encodings for an opcode and function code 
as well as three register fields in Listing~\ref{lis:sampleinstformat}.  

\vspace{0.125in}
\begin{lstlisting}[frame=single,style=base,caption={Sample Instruction Format Definition},captionpos=b,label={lis:sampleinstformat}]
instformat RISC( enc opc, enc func, reg[GPR] RT, reg[GPR] RA, reg[GPR] RB )
\end{lstlisting}

\clearpage
\subsection{Register Class Definitions}
\label{sec:RegClassDef}

Register classes and their associated registers are special variables in the StoneCutter language.  Each defined register 
is must reside within its respective register class.  Registers are marked in the IR with attributes in order to ensure that 
they belong to the correct register class when being utilized in an instruction body.  Each register is also annotated as a global 
variable such that it can be explicitly utilized in any instruction definition body.

\vspace{0.125in}
\begin{lstlisting}[frame=single,style=base,caption={Register Class Definition Syntax},captionpos=b,label={lis:regclass}]
regclass RCName1( DATATYPE RegName1, DATATYPE RegName2, ... )
regclass RCName2( DATATYPE RegName( DATATYPE SubReg1, DATATYPE SubReg2 ) )
\end{lstlisting}

We find the syntax for defining register classes and their associated registers in Listing~\ref{lis:regclass}.  Each register 
class is definition is marked with a \texttt{regclass} keyword followed by the register class name.  Each of the registers 
defined within the register class are enclosed within parenthesis.  Within the parenthesis, each register definition must 
be preceded by its respective datatype (Section~\ref{sec:Datatypes}) and the register name.  Registers are separated 
by commas.  For registers that have subfields, we may also explicitly annotate these within the register definition.  For 
each register with subfields, the subfields are defined within parenthesis attached to the register definition 
(Line 2 in Listing~\ref{lis:regclass}).  Each subfield must also contain its respective datatype.  The combined number of bits for 
all subfields within a register definition must not exceed the total number of bits in that register.  

We find an example register class definition for a simple RISC ISA in Listing~\ref{lis:sampleregclass}.  

\vspace{0.125in}
\begin{lstlisting}[frame=single,style=base,caption={Sample Register Class Definition},captionpos=b,label={lis:sampleregclass}]
regclass GPR( u64 r0, u64 r1, u64 r2, u64 r3, u64 r4, u64 r5, u64 r6, 
		       u64 r7, u64 r8, u64 r9, u64 r10, u64 r11, u64 r12, 
		       u64 r13, u64 r14, u64 r15, u64 r16, u64 r17, u64 r18,
		       u64 r19, u64 r20, u64 r21, u64 r22, u64 r23, u64 r24, 
		       u64 r25, u64 r26, u64 r27, u64 r28, u64 r29, u64 r30,
		       r64 r31 )
regclass CTRL( u64 pc, u64 exc, u64 ne, u64 gt, u64 lt, u64 gte,
			 u64 lte, u64 sp, u64 fp, u64 rp )
\end{lstlisting}

\clearpage
\subsection{Instruction Prototypes}
\label{sec:InstructionPrototypes}

For each instruction defined in the StoneCutter syntax, we must construct 
an instruction prototype.  The instruction prototype is an important and powerful 
feature of the StoneCutter language.  The instruction prototype drives two major 
features in the downstream Chisel HDL produced by a compiled StoneCutter input.  
First, the prototype describes the attachment of the respective instruction implementation 
to the instruction crack logic generated by the CoreGen IR.  The instruction mnemonic 
utilized in the instruction definition must match that of the instruction mnemonic defined 
in the CoreGen IR.  In this manner, the combined StoneCutter and CoreGen IR infrastructure 
logic can match the instruction crack implementation and the instruction implementation (et al. ALU).  

Second, the instruction definition argument list defines the set of standard I/O ports utilized by the 
instruction.  Standard I/O ports are utilized to pipeline register read and write operations within an 
optimized pipeline.  While it is entirely permissible to directly address registers or register files 
from within an instruction definition that are not defined in the argument list, the eventual downstream 
instruction implementation may require additional register read/write operations that induce pipeline 
stalls.  Keep in mind that standard I/O ports such as the clock, register hazarding and stall signals 
are automatically instantiated.  

\vspace{0.125in}
\begin{lstlisting}[frame=single,style=base,caption={Instruction Prototype Format},captionpos=b,label={lis:instprototypeformat}]
def INSTNAME( ARG1 ARG2 ARG3 ... ) {
}
\end{lstlisting}

As mentioned above, the instruction prototype includes two main structures: the instruction 
name and the instruction arguments (Listing~\ref{lis:instprototypeformat}).  The instruction name must match the associated instruction 
name defined in the CoreGen IR.  The instruction name is case sensitive.  
See the CoreGen IR specification for more information~\ref{IRSpec}.  The instruction 
argument list contains a set of register, instruction field or register class names that define the standard I/O functions 
for the optimized pipeline.  The instruction argument list must match the set of register, instruction format fields or register file designators 
in the instruction format for the target instruction. 
  
Register arguments are interpreted literally.  In this manner, a register I/O is performed to the specific 
register index denoted by the target register.  Register class arguments are interpreted logically.  The register 
class arguments utilize the index specified in the assembled instruction payload to load or store from the respective 
register index in the target register file.  

We see an example of a series of instruction prototypes in Listing~\ref{lis:instprototype}.  We utilize the register class 
and register definitions from Section~\ref{sec:RegClassDef}.  We define four instructions, \texttt{add}, \texttt{move}, 
\texttt{inc} and \texttt{sub}.  The \texttt{add} instruction prototype contains a single argument, \texttt{GPR}, that defines I/O ports 
to/from the GPR register class.  The \texttt{move} instruction utilizes both the \texttt{GPR} and the \texttt{CTRL} 
register classes.  The \texttt{inc} instruction utilizes the explicit \texttt{pc} register as well as the \texttt{GPR} 
register class.  Finally, the \texttt{sub} Notice that the arguments within the prototype are \textbf{not} separated by commas.  Further, we see 
that the associated instruction definition body is contained within a set of brackets (\texttt{\{\}}).  

\clearpage
\vspace{0.125in}
\begin{lstlisting}[frame=single,style=base,caption={Instruction Prototype Format},captionpos=b,label={lis:instprototype}]
instformat RISC( enc opc, enc func, reg[GPR] RT, reg[GPR] RA, reg[GPR] RB )
regclass GPR( u64 r0, u64 r1, u64 r2, u64 r3, u64 r4, u64 r5, u64 r6, 
		       u64 r7, u64 r8, u64 r9, u64 r10, u64 r11, u64 r12, 
		       u64 r13, u64 r14, u64 r15, u64 r16, u64 r17, u64 r18,
		       u64 r19, u64 r20, u64 r21, u64 r22, u64 r23, u64 r24, 
		       u64 r25, u64 r26, u64 r27, u64 r28, u64 r29, u64 r30,
		       r64 r31 )
regclass CTRL( u64 pc, u64 exc, u64 ne, u64 gt, u64 lt, u64 gte,
			 u64 lte, u64 sp, u64 fp, u64 rp )

# add operation			 
def add( GPR ){
}

# move between GPR and CTRL 
def move( GPR CTRL ){
}

# increment PC by GPR
def inc( pc GPR ){
}

# subtract RT = RA - RB
def sub( RT RA RB ){
}
\end{lstlisting}

\clearpage
\subsection{Variable Definitions}
\label{sec:Variable Definitions}

In addition to utilizing register classes and register fields as variables within 
an instruction definition, users may also specify local, temporary variables 
in the instruction definition body.  These values may be utilized as temporary 
storage for complex, multi-stage operations, loop counters and other intermediate 
state.  The StoneCutter compiler infrastructure will make every effort to minimize the overall 
hardware impact of these intermediate values to the size and timing of the target design.  As a result, 
these temporary values may be optimized out and/or reused by adjacent instructions 
in the generated downstream Chisel HDL.  

In the same manner as individual registers, variables are required to have a defined type.  
These types follow the same convention as defined in Section~\ref{sec:Datatypes}.  Variable 
names may not collide with existing instruction format fields or register names.  Much in the same 
manner as the C language, StoneCutter permits users to define multiple, independent variables 
using the same datatype.  Variables must also be defined at the \textbf{top} of an instruction 
definition.  This permits StoneCutter to sufficiently scope temporary variables across the body 
of an instruction.  The format of 
variable definitions is noted in Listing~\ref{lis:vardefs}.  We provide an example of a series of 
variable definitions in Listing~\ref{lis:samplevardefs}.  

\vspace{0.125in}
\begin{lstlisting}[frame=single,style=base,caption={Variable Definitions},captionpos=b,label={lis:vardefs}]
def INST( ... ){
  DATATYPE name1
  DATARYPE name2 = VALUE
  DATATYPE name3, name4, ...

  <instruction body>
}
\end{lstlisting}

\vspace{0.125in}
\begin{lstlisting}[frame=single,style=base,caption={Sample Variable Definitions},captionpos=b,label={lis:samplevardefs}]
instformat RISC( enc opc, enc func, reg[GPR] RT, reg[GPR] RA, reg[GPR] RB )

def add( RT RA RB ){
  u64 var1, var2
  if( RA == RB ){
    var1 = 5
    var2 = 6
  }else{
    var1 = 7
    var2 = 998
  }
  RT = var1 & var2
}
\end{lstlisting}

\clearpage
\subsection{Arithmetic Operations}
\label{sec:Arithmetic Operations}

The StoneCutter language supports the standard set of arithmetic operations as defined 
by other C-like languages.  However, given the nature of compiling the StoneCutter language 
to a target-specific circuit design, the StoneCutter compiler and tool chain enforces a number 
of idiosyncratic features when processing variables for arithmetic operations.  First, the StoneCutter 
language scans the variables associated with the left hand side of a target arithmetic operation and automatically 
converts the operation to perform arithmetic using the width of the largest variable.  Further, when 
storing the result of an operation to a target variable or register (right hand side of an operation), StoneCutter 
converts the resulting data to saturate the bit space of the target.  The process of converting 
arithmetic operations and variables to larger bit space is performed using zero extension in order to avoid 
poisoning the numerical consistency of an operation.  Users may override this behavior by utilizing 
sign and zero extended intrinsics (see Section~\ref{sec:ArithIntrinsics}).

We provide a summary of permissible arithmetic operations in Table~\ref{tab:arithops}.   

\begin{table}[h]
\begin{center}
\caption{StoneCutter Arithmetic Operations}
\vspace{0.125in}
\label{tab:arithops}
\begin{tabular}{|c|c|l|}
\hline
\textbf{Operator} & \textbf{Example} & \textbf{Description}\\
\hline
\texttt{=} & \texttt{RT = RB} & Assignment operation\\
\hline
\texttt{+} & \texttt{RT = RA + RB} & Add operation\\
\hline
\texttt{-} & \texttt{RT = RA - RB} & Subtract operation\\
\hline
\texttt{*} & \texttt{RT = RA * RB} & Multiplication operation\\
\hline
\texttt{\textbackslash} & \texttt{RT = RA \textbackslash~RB} & Division operation\\
\hline
\texttt{\%} & \texttt{RT = RA \% RB} & Modulo operation\\
\hline
\texttt{\&} & \texttt{RT = RA \& RB} & Bitwise \textit{and} operation\\
\hline
\texttt{|} & \texttt{RT = RA | RB} & Bitwise \textit{or} operation\\
\hline
\texttt{$\wedge$} & \texttt{RT = RA $\wedge$ RB} & Bitwise \textit{xor} operation\\
\hline
\texttt{<<} & \texttt{RT = RA << RB} & Shift left operation\\
\hline
\texttt{>>} & \texttt{RT = RA >> RB} & Shift right operation\\
\hline
\end{tabular}
\end{center}
\end{table}

\textit{NOTE:} Please note that StoneCutter does not currently support the bitwise complement 
operation (\textasciitilde) and the logical not operation (!).  

\clearpage
\subsection{Conditional Operations}
\label{sec:ConditionalOperations}

\subsubsection{Boolean Operators}
\label{sec:BooleanOperators}

The StoneCutter language syntax supports the standard set of boolean 
operators as is defined by other C-like languages.  The one exception being the 
logical not operation (!).  StoneCutter does not support the logical not operation for 
boolean operations.  Rather, users seeking to complement the result of a boolean operation 
of a singular boolean value must utilize the \texttt{NOT} intrinsic (Section~\ref{sec:NOT}).

We provide a summary of permissible boolean operations in Table~\ref{tab:boolops}.

\begin{table}[h]
\begin{center}
\caption{StoneCutter Boolean Operations}
\vspace{0.125in}
\label{tab:boolops}
\begin{tabular}{|c|c|l|}
\hline
\textbf{Operator} & \textbf{Example} & \textbf{Description}\\
\hline
\texttt{==} & \texttt{RA == RB} & Logical equivalence\\
\hline
\texttt{!=} & \texttt{RA != RB} & Logical in-equivalence\\
\hline
\texttt{<} & \texttt{RA < RB} & Less than\\
\hline
\texttt{>} & \texttt{RA > RB} & Greater than\\
\hline
\texttt{<=} & \texttt{RA <= RB} & Less than or equal to\\
\hline
\texttt{>=} & \texttt{RA >= RB} & Greater than or equal to\\
\hline
\texttt{\&\&} & \texttt{RA \&\& RB} & Logical and\\
\hline
\texttt{||} & \texttt{RA || RB} & Logical or\\
\hline
\end{tabular}
\end{center}
\end{table}

\clearpage
\subsubsection{Flow Control}
\label{sec:FlowControl}

The StoneCutter language provides support for C-like conditional flow 
control using standard \textit{if-else} clauses.  The statements contained 
within these clauses must result in a boolean value that is interrogated in order 
to determine which body of code (circuit) to execute.  Flow control operations 
are required to include a single \textit{if} statement.  They may optionally include 
a complementary \textit{else} statement.   

\vspace{0.125in}
\begin{lstlisting}[frame=single,style=base,caption={Flow Control Syntax},captionpos=b,label={lis:ifelsesyntax}]
if( BOOLEAN OPERATION){
  # Conditional body
}

if( BOOLEAN OPERATION){
  # Conditional if body
}else{
  # Conditional else body
}
\end{lstlisting}

We provide a set of example conditional flow control operations in Listing~\ref{lis:sampleifelsesyntax}.  

\vspace{0.125in}
\begin{lstlisting}[frame=single,style=base,caption={Sample If-Else Syntax},captionpos=b,label={lis:sampleifelsesyntax}]
def add( RT RA RB ){
  if( RA > RB ){
    RB = RA + RB
  }
  
  if( RB < RT ){
    RT = RB
  }else{
    RT = RT << 1
  }
}
\end{lstlisting}

\clearpage
\subsection{Loop Operations}
\label{sec:LoopOperations}

\subsubsection{For Loops}
\label{sec:ForLoops}

The first style of loop statement supported by the StoneCutter language is the 
\textit{for} loop.  The StoneCutter for loop is structured in a similar manner as the 
traditional C for loop.  The loop is provided with a base case loop counter, a loop 
termination statement and an optional iterator trip step.  The loop counter 
can be an existing variable or a newly defined temporary variable.  Unlike other 
temporary variables, loop trip counters can be defined inline within the for loop 
structure.  The loop termination statement includes one or more comparison 
statements that define the termination state of the loop using the loop trip 
counter.  The optional loop trip counter iterator can be an immediate value or a variable.  
If this optional value is not specified, the iterator value is assumed to be "1".  The for loop body 
is contained with brackets (\texttt{\{\}}) and may include any other set of StoneCutter statements.  The for loop 
syntax is depicted in Listing~\ref{lis:forloopsyntax}.     

\vspace{0.125in}
\begin{lstlisting}[frame=single,style=base,caption={For Loop Syntax},captionpos=b,label={lis:forloopsyntax}]
for( LOOPTRIP = BASE; LOOPTRIP <COMPARATOR> TERMINATOR ){
  # for loop body
}

for( LOOPTRIP = BASE; LOOPTRIP <COMPARATOR> TERMINATOR; ITERATOR ){
  # for loop body
}
\end{lstlisting}

The comparator operation utilized to terminate the loop is one of the standard 
variable comparison operations from C-like languages.  We summarize these operators in 
Table~\ref{tab:compreops}.  

\begin{table}[h]
\begin{center}
\caption{StoneCutter Comparison Operations}
\vspace{0.125in}
\label{tab:compreops}
\begin{tabular}{|c|l|}
\hline
\textbf{Operator} & \textbf{Description} \\
\texttt{<} & Less Than\\
\hline
\texttt{>} & Greater Than\\
\hline
\texttt{<=} & Less Than Or Equal To\\
\hline
\texttt{>=} & Greater Than Or Equal To\\
\hline
\texttt{==} & Equal To\\
\hline
\texttt{!=} & Not Equal To\\
\hline
\end{tabular}
\end{center}
\end{table}

We provide a set of example for loops in Listing~\ref{lis:sampleforloopsyntax}.  

\vspace{0.125in}
\begin{lstlisting}[frame=single,style=base,caption={Sample For Loop Syntax},captionpos=b,label={lis:sampleforloopsyntax}]
def add( RT RA RB ){
  u64 var1
  for( i = 1; i < RA ){
    RB = RB + 1
  }
  for( j = 0; i< RB; 5 )
    RT = RB | RT
  }
  for( var = 1024; i <= RT; RB ){
    RT = var
  }
}
\end{lstlisting}

\subsubsection{While Loops}
\label{sec:WhileLoops}

The second style of loop supported by the StoneCutter language is the \textit{while} loop.  The StoneCutter 
while loop is structured in a similar manner as the traditional C while loop.  The loop is provided with a 
termination statement in the form of a comparator.  It is up to the user to modify the variable utilized 
in the comparator statement such that a valid termination state can be reached.  StoneCutter does not otherwise 
validate the potential for infinite while loops.  The while loop body is contained within brackets 
(\texttt{\{\}}) and may include any other set of StoneCutter statements.  The while loop syntax is depicted in 
Listing~\ref{lis:whileloopsyntax}.  

\vspace{0.125in}
\begin{lstlisting}[frame=single,style=base,caption={While Loop Syntax},captionpos=b,label={lis:whileloopsyntax}]
while( COMPARATOR STATEMENT ){
  # while loop body
}
\end{lstlisting}

We provide a set of example while loops in Listing~\ref{lis:samplewhileloopsyntax}.

\vspace{0.125in}
\begin{lstlisting}[frame=single,style=base,caption={Sample While Loop Syntax},captionpos=b,label={lis:samplewhileloopsyntax}]
def add( RT RA RB ){
  u64 var1 = 1024
  while( RA < RB ){
    RT = RB << 1
    RA = RA + 1
  }
  while( var1 >= RT ){
    var1 = var1 - 5
    RT = RT << 1
  }
}
\end{lstlisting}

\clearpage
\subsubsection{Do While Loops}
\label{sec:DoWhileLoops}

The final style of loop supported by the StoneCutter language is the \textit{do while} loop.  The StoneCutter do while 
loop is structured in a similar manner as the traditional the traditional C do while loop.  The loop is provided with 
an entry state provided by a \textit{do} statement.  The do statement is followed by a loop body contained within brackets 
(\texttt{\{\}}).  The do while loop termination statement follows the last bracket and is contained in a \textit{while} block similar 
in form as the while loop structure (Section~\ref{sec:WhileLoops}).  The while loop syntax is depicted in 
Listing~\ref{lis:dowhileloopsyntax}.   

\vspace{0.125in}
\begin{lstlisting}[frame=single,style=base,caption={Do While Loop Syntax},captionpos=b,label={lis:dowhileloopsyntax}]
do{
  # do while loop body
}while( COMPARATOR STATEMENT )
\end{lstlisting}

We provide a set of example do while loops in Listing~\ref{lis:sampledowhileloopsyntax}.

\vspace{0.125in}
\begin{lstlisting}[frame=single,style=base,caption={Sample Do While Loop Syntax},captionpos=b,label={lis:sampledowhileloopsyntax}]
def add( RT RA RB ){
  u64 var1 = 1024
  do{
    RT = RB << 1
    RA = RA + 1
  }while( RA < RB )  
  do{
    var1 = var1 - 5
    RT = RT << 1
  }while( var1 >= RT )
}
\end{lstlisting}

%----------------------------------------------------------------------------------------
%	SECTION 3
%----------------------------------------------------------------------------------------
\clearpage
\section{Intrinsic Functions}
\label{sec:IntrinsicFunctions}

\subsection{Overview}
\label{sec:IntrinsicOverview}

In the same manner as other C-like languages and compiler infrastructures, 
the StoneCutter language provides a notional set of builtin intrinsic functions.  
Much like other languages, these intrinsic functions provide pathological 
circuit functionality in a convenient and optimized package.  However, 
unlike traditional strongly typed languages that provide unique intrinsic 
functions for disparate data types, the StoneCutter language provides 
single intrinsics that support all possible StoneCutter data types.  In this manner, 
the StoneCutter compiler infrastructure interrogates the arguments of each intrinsic 
at compile time and constructs an optimized Chisel representation of the target 
operation using the user-specified types.  As a result, users may utilize the forthcoming 
set of intrinsic operations with any target data types supported by the StoneCutter language.  

StoneCutter intrinsics are classified as two disparate types: \textit{Arithmetic} intrinsics and 
\textit{Memory} intrinsics.  Arithmetic intrinsics perform some notional permutation on the target 
input data.  Arithmetic intrinsics generally require input and return the output as a unique data 
member (\texttt{OUTPUT = INTRINSIC( INPUT )}).  Data members are not modified in place.  
Memory intrinsics are different in that they interact with the memory infrastructure generated 
by the CoreGen~\cite{IRSpec} code generation facilities such that the desired function unit may interact with 
external memories such as caches and off-chip memory units.  Memory intrinsics are generally 
provide functionality such as \textit{load} and \textit{store} operations.  

StoneCutter intrinsic operations may be utilized anywhere within the body of an instruction definition.  
The initial StoneCutter language parser \textit{lowers} any encountered intrinsic operations to the equivalent 
of a function call.  The StoneCutter code generator expands these intrinsic function calls into their 
full circuit descriptions using the target input and output types.  In this manner, including intrinsics within 
the body of conditional flow control, loops and other basic blocks is both type safe and functionally sound.    

Intrinsics can be utilized similar to C-style function calls.  Intrinsics names are placed in the instruction body 
with the appropriate number of arguments.  Intrinsic arguments are separated by commas.  Intrinsics that return 
values can be utilized within other expressions and/or assigned to values (\texttt{RT = INTRIN(..)}).  
The syntax for utilizing intrinsics is depicted in Listing~\ref{lis:intrinsyntax}.  A summary of the intrinsics is provided 
in Section~\ref{sec:AppendixB}.    

\vspace{0.125in}
\begin{lstlisting}[frame=single,style=base,caption={Intrinsic Syntax},captionpos=b,label={lis:intrinsyntax}]
def add( RT RA RB ){
  u64 var1, var2
  INTRIN( RB )
  RB = INTRIN( RA )
  RT = INTRIN( RA, RB )
}
\end{lstlisting}

\clearpage
\subsection{Arithmetic Intrinsics}
\label{sec:ArithIntrinsics}

\subsubsection{CLZ}
\label{sec:CLZ}

\begin{table}[h]
\begin{center}
\caption{CLZ Intrinsic}
\vspace{0.125in}
\label{tab:CLZIntrinsic}
\begin{tabular}{|c|l|}
\hline
\textbf{Mnemonic} & \texttt{RT = CLZ(RA)}\\
\hline
\textbf{Description} & Counts the leading zeros (little endian)\\
\hline
\multirow{2}{*}{\textbf{Arguments}} & RA: Contains the value to count the leading zeros\\
                          			     & \\
\hline
\multirow{3}{*}{\textbf{Example}} & def INST(RA RB RT)\{\\
                          			  &   RT = CLZ(RA)\\
                                                    & \}\\
\hline
\textbf{Return} & The number of leading zeros in the input value\\                                                    
\hline
\end{tabular}
\end{center}
\end{table}

\clearpage
\subsubsection{COMPRESS}
\label{sec:COMPRESS}

\begin{table}[h]
\begin{center}
\caption{COMPRESS Intrinsic}
\vspace{0.125in}
\label{tab:COMPRESSIntrinsic}
\begin{tabular}{|c|l|}
\hline
\textbf{Mnemonic} & \texttt{RT = COMPRESS(RA)}\\
\hline
\multirow{2}{*}{\textbf{Description}} & Bit compression.  For the number of '1' values in RA, set the least significant \\
						      & bits to '1'.  Zero extend the result.\\
\hline
\multirow{2}{*}{\textbf{Arguments}} & RA: Contains the value to compress\\
                          			     & \\
\hline
\multirow{3}{*}{\textbf{Example}} & def INST(RA RB RT)\{\\
                          			  &   RT = COMPRESS(RA)\\
                                                    & \}\\
\hline
\textbf{Return} & The compressed version of RA\\                                                    
\hline
\end{tabular}
\end{center}
\end{table}

\clearpage
\subsubsection{COMPRESSM}
\label{sec:COMPRESSM}

\begin{table}[h]
\begin{center}
\caption{COMPRESSM Intrinsic}
\vspace{0.125in}
\label{tab:COMPRESSMIntrinsic}
\begin{tabular}{|c|l|}
\hline
\textbf{Mnemonic} & \texttt{RT = COMPRESSM(RA,RB)}\\
\hline
\multirow{3}{*}{\textbf{Description}} & Bit compression under mask.  Perform a bitwise `\&` operation of the input and bitmask. \\
						      & For the number of '1' values in the result, set the least significant \\
						      & bits to '1'.  Zero extend the result.\\
\hline
\multirow{2}{*}{\textbf{Arguments}} & RA: Contains the value to compress\\
                          			     & RB: Contains the bitmask to select compression bits \\
\hline
\multirow{3}{*}{\textbf{Example}} & def INST(RA RB RT)\{\\
                          			  &   RT = COMPRESSM(RA, RB)\\
                                                    & \}\\
\hline
\textbf{Return} & The compressed version of RA via the bitmask RB\\                                                    
\hline
\end{tabular}
\end{center}
\end{table}

\clearpage
\subsubsection{CTZ}
\label{sec:CTZ}

\begin{table}[h]
\begin{center}
\caption{CTZ Intrinsic}
\vspace{0.125in}
\label{tab:CTZIntrinsic}
\begin{tabular}{|c|l|}
\hline
\textbf{Mnemonic} & \texttt{RT = CTZ(RA)}\\
\hline
\textbf{Description} & Counts the trailing zeros (little endian)\\
\hline
\multirow{2}{*}{\textbf{Arguments}} & RA: Contains the value to count the trailing zeros\\
                          			     & \\
\hline
\multirow{3}{*}{\textbf{Example}} & def INST(RA RB RT)\{\\
                          			  &   RT = CTZ(RA)\\
                                                    & \}\\
\hline
\textbf{Return} & The number of trailing zeros in the input value\\                                                    
\hline
\end{tabular}
\end{center}
\end{table}

\clearpage
\subsubsection{DOZ}
\label{sec:DOZ}

\begin{table}[h]
\begin{center}
\caption{DOZ Intrinsic}
\vspace{0.125in}
\label{tab:DOZIntrinsic}
\begin{tabular}{|c|l|}
\hline
\textbf{Mnemonic} & \texttt{RT = DOZ(RA,RB)}\\
\hline
\multirow{2}{*}{\textbf{Description}} & Performs "first grade subtraction."  Returns $(RA-RB)$ IFF $RA >= RB$.\\
			      			      & Returns 0 otherwise\\
\hline
\multirow{2}{*}{\textbf{Arguments}} & RA: Contains the left hand input value \\
                          			     & RB: Contains the right hand input value \\
\hline
\multirow{3}{*}{\textbf{Example}} & def INST(RA RB RT)\{\\
                          			  &   RT = DOZ(RA, RB)\\
                                                    & \}\\
\hline
\textbf{Return} & If( $RA >=$ RB ) \{ return $RA-RB$ \}else\{ return 0 \}\\                                                    
\hline
\end{tabular}
\end{center}
\end{table}

\clearpage
\subsubsection{EXTRACTS}
\label{sec:EXTRACTS}

\begin{table}[h]
\begin{center}
\caption{EXTRACTS Intrinsic}
\vspace{0.125in}
\label{tab:EXTRACTSIntrinsic}
\begin{tabular}{|c|l|}
\hline
\textbf{Mnemonic} & \texttt{EXTRACTS(RA,RB,RC)}\\
\hline
\textbf{Description} & Extract the target field starting a bit position RC from RB, store into RA and sign extend.\\
\hline
\multirow{3}{*}{\textbf{Arguments}} & RA: Contains the target output value\\
                          			     & RB: Input value to extract from \\
			                              & RC: Starting bit position\\
\hline
\multirow{3}{*}{\textbf{Example}} & def INST(RA RB RC RT)\{\\
                          			  &   EXTRACTS(RA, RB, RC)\\
                                                    & \}\\
\hline
\textbf{Return} & Nothing is returned\\                                                    
\hline
\end{tabular}
\end{center}
\end{table}

\clearpage
\subsubsection{EXTRACTZ}
\label{sec:EXTRACTZ}

\begin{table}[h]
\begin{center}
\caption{EXTRACTZ Intrinsic}
\vspace{0.125in}
\label{tab:EXTRACTZIntrinsic}
\begin{tabular}{|c|l|}
\hline
\textbf{Mnemonic} & \texttt{EXTRACTZ(RA,RB,RC)}\\
\hline
\textbf{Description} & Extract the target field starting a bit position RC from RB, store into RA and zero extend.\\
\hline
\multirow{3}{*}{\textbf{Arguments}} & RA: Contains the target input value\\
                          			     & RB: Input value to extract from \\
			                              & RC: Starting bit position\\
\hline
\multirow{3}{*}{\textbf{Example}} & def INST(RA RB RC RT)\{\\
                          			  &   EXTRACTZ(RA, RB, RC)\\
                                                    & \}\\
\hline
\textbf{Return} & Nothing is returned\\                                                    
\hline
\end{tabular}
\end{center}
\end{table}

\clearpage
\subsubsection{INSERTS}
\label{sec:INSERTS}

\begin{table}[h]
\begin{center}
\caption{INSERTS Intrinsic}
\vspace{0.125in}
\label{tab:INSERTSIntrinsic}
\begin{tabular}{|c|l|}
\hline
\textbf{Mnemonic} & \texttt{INSERTS(RA,RB, RC)}\\
\hline
\textbf{Description} & Insert the field (RB) into RA starting at bit position RC and sign extend\\
\hline
\multirow{3}{*}{\textbf{Arguments}} & RA: Contains the target input value\\
                          			     & RB: Input value to insert\\
			                              & RC: Starting bit position\\
\hline
\multirow{3}{*}{\textbf{Example}} & def INST(RA RB RC RT)\{\\
                          			  &   INSERTS(RA, RB, RC)\\
                                                    & \}\\
\hline
\textbf{Return} & Nothing is returned\\                                                    
\hline
\end{tabular}
\end{center}
\end{table}

\clearpage
\subsubsection{INSERTZ}
\label{sec:INSERTZ}

\begin{table}[h]
\begin{center}
\caption{INSERTZ Intrinsic}
\vspace{0.125in}
\label{tab:INSERTZIntrinsic}
\begin{tabular}{|c|l|}
\hline
\textbf{Mnemonic} & \texttt{INSERTZ(RA,RB,RC)}\\
\hline
\textbf{Description} & Insert the field (RB) into RA starting at bit position RC and zero extend\\
\hline
\multirow{3}{*}{\textbf{Arguments}} & RA: Contains the target input value\\
                          			     & RB: Input value to insert\\
			                              & RC: Starting a bit position\\
\hline
\multirow{3}{*}{\textbf{Example}} & def INST(RA RB RC RT)\{\\
                          			  &   INSERTZ(RA, RB, RC)\\
                                                    & \}\\
\hline
\textbf{Return} & Nothing is returned\\                                                    
\hline
\end{tabular}
\end{center}
\end{table}

\clearpage
\subsubsection{MAJ}
\label{sec:MAJ}

\begin{table}[h]
\begin{center}
\caption{MAJ Intrinsic}
\vspace{0.125in}
\label{tab:MAJIntrinsic}
\begin{tabular}{|c|l|}
\hline
\textbf{Mnemonic} & \texttt{RT = MAJ(RA,RB,RC)}\\
\hline
\multirow{2}{*}{\textbf{Description}} & Performs a majority vote of the values RA,RB and RC.\\
             					      & Returns true if at least two inputs are true; returns false otherwise\\
\hline
\multirow{3}{*}{\textbf{Arguments}} & RA: Input 1\\
                          			     & RB: Input 2\\
			     			     & RC: Input3\\
\hline
\multirow{3}{*}{\textbf{Example}} & def INST(RA RB RC RT)\{\\
                          			  &   RT = MAJ(RA, RB, RC)\\
                                                    & \}\\
\hline
\textbf{Return} & Returns true if at least two inputs are true; returns false otherwise\\                                                    
\hline
\end{tabular}
\end{center}
\end{table}

\clearpage
\subsubsection{MAX}
\label{sec:MAX}

\begin{table}[h]
\begin{center}
\caption{MAX Intrinsic}
\vspace{0.125in}
\label{tab:MAXIntrinsic}
\begin{tabular}{|c|l|}
\hline
\textbf{Mnemonic} & \texttt{RT = MAX(RA,RB)}\\
\hline
\textbf{Description} & Returns the maximum value of RA and RB\\
\hline
\multirow{2}{*}{\textbf{Arguments}} & RA: Input 1\\
                          			     & RB: Input 2\\
\hline
\multirow{3}{*}{\textbf{Example}} & def INST(RA RB RT)\{\\
                          			  &   RT = MAX(RA, RB)\\
                                                    & \}\\
\hline
\textbf{Return} & If( RA $>$ RB )\{ return RA \}else\{ return RB\}\\                                                    
\hline
\end{tabular}
\end{center}
\end{table}

\clearpage
\subsubsection{MERGE}
\label{sec:MERGE}

\begin{table}[h]
\begin{center}
\caption{MERGE Intrinsic}
\vspace{0.125in}
\label{tab:MERGEIntrinsic}
\begin{tabular}{|c|l|}
\hline
\textbf{Mnemonic} & \texttt{MERGE(RA,RB,RC)}\\
\hline
\textbf{Description} & Selectively merge bits specified by the mask in RC from RB into RA\\
\hline
\multirow{3}{*}{\textbf{Arguments}} & RA: Contains the target data to merge into\\
                          			     & RB: Contains the value to selectively merge\\
			     			     & RC: Contains bitwise mask input\\
\hline
\multirow{3}{*}{\textbf{Example}} & def INST(RA RB RT)\{\\
                          			  &   MERGE(RA, RB, RC)\\
                                                    & \}\\
\hline
\textbf{Return} & Nothing is returned\\                                                    
\hline
\end{tabular}
\end{center}
\end{table}

\clearpage
\subsubsection{MIN}
\label{sec:MIN}

\begin{table}[h]
\begin{center}
\caption{MIN Intrinsic}
\vspace{0.125in}
\label{tab:MINIntrinsic}
\begin{tabular}{|c|l|}
\hline
\textbf{Mnemonic} & \texttt{RT = MIN(RA,RB)}\\
\hline
\textbf{Description} & Returns the minimum value of RA and RB\\
\hline
\multirow{2}{*}{\textbf{Arguments}} & RA: Input1\\
                          			     & RB: Input2\\
\hline
\multirow{3}{*}{\textbf{Example}} & def INST(RA RB RT)\{\\
                          			  &   RT = MIN(RA, RB)\\
                                                    & \}\\
\hline
\textbf{Return} & If( RA $<$ RB )\{ return RA \}else\{ return RB\}\\                                                    
\hline
\end{tabular}
\end{center}
\end{table}

\clearpage
\subsubsection{NOT}
\label{sec:NOT}

\begin{table}[h]
\begin{center}
\caption{NOT Intrinsic}
\vspace{0.125in}
\label{tab:NOTIntrinsic}
\begin{tabular}{|c|l|}
\hline
\textbf{Mnemonic} & \texttt{RT = NOT(RA)}\\
\hline
\multirow{3}{*}{\textbf{Description}} & Returns the bitwise complement of the input value.  If the input value is \\
						      & a single bit boolean (\texttt{u1}), the logical complement is returned.  If \\
						      & the input value is larger than a single bit, the bitwise complement is returned\\
\hline
\textbf{Arguments} & RA: Contains the input to be complemented\\
\hline
\multirow{3}{*}{\textbf{Example}} & def INST(RA RB RT)\{\\
                          			  &   RT = NOT(RA)\\
                                                    & \}\\
\hline
\textbf{Return} & Bitwise complement of RA\\                                                    
\hline
\end{tabular}
\end{center}
\end{table}

\clearpage
\subsubsection{POPCOUNT}
\label{sec:POPCOUNT}

\begin{table}[h]
\begin{center}
\caption{POPCOUNT Intrinsic}
\vspace{0.125in}
\label{tab:POPCOUNTIntrinsic}
\begin{tabular}{|c|l|}
\hline
\textbf{Mnemonic} & \texttt{RT = POPCOUNT(RA)}\\
\hline
\textbf{Description} & Returns the population count of the input variable.\\
\hline
\textbf{Arguments} & RA: Contains the input value for the popcount\\
                          			     
\hline
\multirow{3}{*}{\textbf{Example}} & def INST(RA RB RT)\{\\
                          			  &   RT = POPCOUNT(RA)\\
                                                    & \}\\
\hline
\multirow{2}{*}{\textbf{Return}} & The number of positive (1) bits in the input value is returned.  The output storage must \\
			& contain sufficient space to storage the maximum popcount value (all positive bits)\\                                                    
\hline
\end{tabular}
\end{center}
\end{table}

\clearpage
\subsubsection{REVERSE}
\label{sec:REVERSE}

\begin{table}[h]
\begin{center}
\caption{REVERSE Intrinsic}
\vspace{0.125in}
\label{tab:REVERSEIntrinsic}
\begin{tabular}{|c|l|}
\hline
\textbf{Mnemonic} & \texttt{RT = REVERSE(RA)}\\
\hline
\textbf{Description} & Reverse the bit pattern of the input variable\\
\hline
\textbf{Arguments} & RA: Contains the input to be reversed\\
\hline
\multirow{3}{*}{\textbf{Example}} & def INST(RA RB RT)\{\\
                          			  &   RT = REVERSE(RA)\\
                                                    & \}\\
\hline
\textbf{Return} & The reversed bit pattern of the input variable\\                                                    
\hline
\end{tabular}
\end{center}
\end{table}

\clearpage
\subsubsection{ROTL}
\label{sec:ROTL}

\begin{table}[h]
\begin{center}
\caption{ROTL Intrinsic}
\vspace{0.125in}
\label{tab:ROTLIntrinsic}
\begin{tabular}{|c|l|}
\hline
\textbf{Mnemonic} & \texttt{RT = ROTL(RA,RB)}\\
\hline
\textbf{Description} & Rotate the value in RA by RB bits to the left.\\
\hline
\multirow{2}{*}{\textbf{Arguments}} & RA: Contains the value to be rotated\\
                          			     & RB: Contains the number of bits to rotate by \\
\hline
\multirow{3}{*}{\textbf{Example}} & def INST(RA RB RT)\{\\
                          			  &   RT = ROTL(RA, RB)\\
                                                    & \}\\
\hline
\textbf{Return} & The input value is rotated left by RB bits\\                                                    
\hline
\end{tabular}
\end{center}
\end{table}

\clearpage
\subsubsection{ROTR}
\label{sec:ROTR}

\begin{table}[h]
\begin{center}
\caption{ROTR Intrinsic}
\vspace{0.125in}
\label{tab:ROTRIntrinsic}
\begin{tabular}{|c|l|}
\hline
\textbf{Mnemonic} & \texttt{RT = ROTR(RA,RB)}\\
\hline
\textbf{Description} & Rotate the value in RA by RB bits to the right.\\
\hline
\multirow{2}{*}{\textbf{Arguments}} & RA: Contains the value to be rotated\\
                          			     & RB: Contains the number of bits to rotate by \\
\hline
\multirow{3}{*}{\textbf{Example}} & def INST(RA RB RT)\{\\
                          			  &   RT = ROTR(RA, RB)\\
                                                    & \}\\
\hline
\textbf{Return} & The input value is rotated right by RB bits\\                                                    
\hline
\end{tabular}
\end{center}
\end{table}

\clearpage
\subsubsection{SEXT}
\label{sec:SEXT}

\begin{table}[h]
\begin{center}
\caption{SEXT Intrinsic}
\vspace{0.125in}
\label{tab:SEXTIntrinsic}
\begin{tabular}{|c|l|}
\hline
\textbf{Mnemonic} & \texttt{Rt = SEXT(RA)}\\
\hline
\textbf{Description} & Sign extend the input value\\
\hline
\textbf{Arguments} & RA: Contains the input value to sign extend\\
\hline
\multirow{3}{*}{\textbf{Example}} & def INST(RA RB RT)\{\\
                          			  &   RT = SEXT(RA)\\
                                                    & \}\\
\hline
\textbf{Return} & The sign extended version of the input\\                                                    
\hline
\end{tabular}
\end{center}
\end{table}

\clearpage
\subsubsection{ZEXT}
\label{sec:ZEXT}

\begin{table}[h]
\begin{center}
\caption{ZEXT Intrinsic}
\vspace{0.125in}
\label{tab:ZEXTIntrinsic}
\begin{tabular}{|c|l|}
\hline
\textbf{Mnemonic} & \texttt{ZEXT(RA,RB)}\\
\hline
\textbf{Description} & Zero extend the input value\\
\hline
\textbf{Arguments} & RA: Contains the input value to zero extend\\
\hline
\multirow{3}{*}{\textbf{Example}} & def INST(RA RB RT)\{\\
                          			  &   RT = ZEXT(RA)\\
                                                    & \}\\
\hline
\textbf{Return} & The zero extended version of the input\\                                                    
\hline
\end{tabular}
\end{center}
\end{table}

\clearpage
\subsection{Memory Intrinsics}
\label{sec:MemIntrinsics}

\subsubsection{LOAD}
\label{sec:LOAD}

\begin{table}[h]
\begin{center}
\caption{LOAD Intrinsic}
\vspace{0.125in}
\label{tab:LOADIntrinsic}
\begin{tabular}{|c|l|}
\hline
\textbf{Mnemonic} & \texttt{RT = LOAD(RA)}\\
\hline
\textbf{Description} & Load the value at the address in RA.  Attempt to derive the datatype\\
\hline
\textbf{Arguments} & RA: Contains the target address \\
\hline
\multirow{3}{*}{\textbf{Example}} & def INST(RA RB RT)\{\\
                          			  &   RT = LOAD(RA)\\
                                                    & \}\\
\hline
\textbf{Return} & The data from the load operation\\                                                    
\hline
\end{tabular}
\end{center}
\end{table}

\clearpage
\subsubsection{STORE}
\label{sec:STORE}

\begin{table}[h]
\begin{center}
\caption{STORE Intrinsic}
\vspace{0.125in}
\label{tab:STOREIntrinsic}
\begin{tabular}{|c|l|}
\hline
\textbf{Mnemonic} & \texttt{STORE(RA,RB)}\\
\hline
\textbf{Description} & foo\\
\hline
\multirow{2}{*}{\textbf{Arguments}} & RA: Contains the data to be stored\\
                          			     & RB: Contains the target address \\
\hline
\multirow{3}{*}{\textbf{Example}} & def INST(RA RB RT)\{\\
                          			  &   STORE(RA, RB)\\
                                                    & \}\\
\hline
\textbf{Return} & Nothing is returned\\                                                    
\hline
\end{tabular}
\end{center}
\end{table}

\clearpage
\subsubsection{LOADELEM}
\label{sec:LOADELEM}

\begin{table}[h]
\begin{center}
\caption{LOADELEM Intrinsic}
\vspace{0.125in}
\label{tab:LOADELEMIntrinsic}
\begin{tabular}{|c|l|}
\hline
\textbf{Mnemonic} & \texttt{RT = LOADELEM(RA,RB)}\\
\hline
\textbf{Description} & Load the value at the address in RA.  The element size is contained in RB. \\
\hline
\multirow{2}{*}{\textbf{Arguments}} & RA: Contains the target address\\
                          			     & RB: Contains the size of the element \\
\hline
\multirow{3}{*}{\textbf{Example}} & def INST(RA RB RT)\{\\
                          			  &   RT = LOADELEM(RA, RB)\\
                                                    & \}\\
\hline
\textbf{Return} & The data from the load operation\\                                                    
\hline
\end{tabular}
\end{center}
\end{table}

\clearpage
\subsubsection{STOREELEM}
\label{sec:STOREELEM}

\begin{table}[h]
\begin{center}
\caption{STOREELEM Intrinsic}
\vspace{0.125in}
\label{tab:STOREELEMIntrinsic}
\begin{tabular}{|c|l|}
\hline
\textbf{Mnemonic} & \texttt{STOREELEM(RA,RB,RC)}\\
\hline
\textbf{Description} & Stores the data in RA to the address at RB.  The element size is contained in RC.\\
\hline
\multirow{3}{*}{\textbf{Arguments}} & RA: Contains the data to be stored\\
                          			     & RB: Contains the target address \\
			     			     & RC: Contains the size of the element \\
\hline
\multirow{3}{*}{\textbf{Example}} & def INST(RA RB RC RT)\{\\
                          			  &   STOREELEM(RA, RB, RC)\\
                                                    & \}\\
\hline
\textbf{Return} & Nothing is returned\\                                                    
\hline
\end{tabular}
\end{center}
\end{table}

%----------------------------------------------------------------------------------------
%	SECTION: Appendix A: Sample IR
%----------------------------------------------------------------------------------------
\clearpage
\section{Appendix A: Sample StoneCutter Implementation}
\label{sec:AppendixA}

\vspace{0.125in}
\lstinputlisting[frame=single,style=base,caption={Sample StoneCutter},captionpos=b,label={lis:samplescfile}]{SAMPLE.sc}

%----------------------------------------------------------------------------------------
%	SECTION: Appendix B: Intrinsic Operation Table
%----------------------------------------------------------------------------------------
\clearpage
\section{Appendix B: Intrinsic Function Table}
\label{sec:AppendixB}

\begin{table}[h]
\begin{center}
\caption{StoneCutter Intrinsics}
\vspace{0.125in}
\label{tab:scintrins}
\begin{tabular}{|c|c|c|l|l}
\hline
\textbf{Intrinsic} & \textbf{Inputs} & \textbf{Outputs} & \textbf{Description}\\
\hline
\hyperref[sec:CLZ]{\texttt{CLZ}} & 1 & 1 & Count leading zero\\
\hline
\hyperref[sec:COMPRESS]{\texttt{COMPRESS}} & 1 & 1 & Bit compress\\
\hline
\hyperref[sec:COMPRESSM]{\texttt{COMPRESSM}} & 1 & 2 & Bit compress under mask\\
\hline
\hyperref[sec:CTZ]{\texttt{CTZ}} & 1 & 1 & Count trailing zero\\
\hline
\hyperref[sec:DOZ]{\texttt{DOZ}} & 1 & 2 & First grade subtraction\\
\hline
\hyperref[sec:EXTRACTS]{\texttt{EXTRACTS}} & 0 & 3 & Bit extract and sign extend\\
\hline
\hyperref[sec:EXTRACTZ]{\texttt{EXTRACTZ}} & 0 & 3 & Bit extract and zero extend\\
\hline
\hyperref[sec:INSERTS]{\texttt{INSERTS}} & 0 & 3 & Bit insert and sign extend\\
\hline
\hyperref[sec:INSERTZ]{\texttt{INSERTZ}} & 0 & 3 & Bit insert and zero extend\\
\hline
\hyperref[sec:MAJ]{\texttt{MAJ}} & 1 & 3 & Majority vote\\
\hline
\hyperref[sec:MAX]{\texttt{MAX}} & 1 & 2 & Max\\
\hline
\hyperref[sec:MERGE]{\texttt{MERGE}} & 0 & 3 & Merge under mask\\
\hline
\hyperref[sec:MIN]{\texttt{MIN}} & 1 & 2 & Min\\
\hline
\hyperref[sec:NOT]{\texttt{NOT}} & 1 & 1 & Bit complement\\
\hline
\hyperref[sec:POPCOUNT]{\texttt{POPCOUNT}} & 1 & 1 & Population count\\
\hline
\hyperref[sec:REVERSE]{\texttt{REVERSE}} & 1 & 1 & Bit reverse\\
\hline
\hyperref[sec:ROTL]{\texttt{ROTL}} & 1 & 2 & Rotate left\\
\hline
\hyperref[sec:ROTR]{\texttt{ROTR}} & 1 & 2 & Rotate right\\
\hline
\hyperref[sec:SEXT]{\texttt{SEXT}} & 1 & 1 & Signe extend\\
\hline
\hyperref[sec:ZEXT]{\texttt{ZEXT}} & 1 & 2 & Zero extend\\
\hline
\hyperref[sec:LOAD]{\texttt{LOAD}} & 1 & 1 & Memory load\\
\hline
\hyperref[sec:STORE]{\texttt{STORE}} & 0 & 2 & Memory store\\
\hline
\hyperref[sec:LOADELEM]{\texttt{LOADELEM}} & 1 & 2 & Memory element load\\
\hline
\hyperref[sec:STOREELEM]{\texttt{STOREELEM}} & 0 & 3 & Memory element store\\
\hline
\end{tabular}
\end{center}
\end{table}

%----------------------------------------------------------------------------------------
%	BIBLIOGRAPHY
%----------------------------------------------------------------------------------------

\clearpage
\bibliography{refs.bib}
\bibliographystyle{IEEEtran}


%----------------------------------------------------------------------------------------


\end{document}
